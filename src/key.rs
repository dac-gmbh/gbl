use crate::Error;

use hex::FromHex;

/// A symmetric AES-128 encryption/decryption key.
///
/// Can be obtained from a variety of formats and is used by [`Gbl::encrypt`]
/// and [`Gbl::decrypt`].
///
/// [`Gbl::encrypt`]: struct.Gbl.html#method.encrypt
/// [`Gbl::decrypt`]: struct.Gbl.html#method.decrypt
pub struct AesKey([u8; 16]);

impl AesKey {
    /// Creates an AES key from 16 raw bytes.
    ///
    /// # Examples
    ///
    /// ```
    /// # use gbl::*;
    /// # fn run() -> Result<(), Error> {
    /// let key = AesKey::from_raw([
    ///		0xE7, 0xE5, 0x56, 0xB6, 0x35, 0xA3, 0x52, 0x06, // 8
    /// 	0x59, 0xA2, 0xE1, 0x61, 0xCB, 0xDF, 0x4B, 0xC2, // 16
    ///	]);
    /// # Ok(()) }    fn main() { run().unwrap() }
    /// ```
    pub fn from_raw(raw: [u8; 16]) -> Self {
        AesKey(raw)
    }

    /// Creates an AES key from a byte slice containing 16 bytes.
    ///
    /// If the slice does not contain exactly 16 bytes, returns `None`.
    ///
    /// # Examples
    ///
    /// ```
    /// # use gbl::*;
    /// # fn run() -> Result<(), Error> {
    /// assert!(AesKey::from_slice(&[
    ///		0xE7, 0xE5, 0x56, 0xB6, 0x35, 0xA3, 0x52, 0x06, // 8
    /// 	0x59, 0xA2, 0xE1, 0x61, 0xCB, 0xDF, 0x4B, 0xC2, // 16
    ///	]).is_some());
    /// # Ok(()) }    fn main() { run().unwrap() }
    /// ```
    ///
    /// Note that it is preferrable to use [`AesKey::from_raw`] when you already
    /// have a fixed-size array of 16 Bytes.
    ///
    /// When the slice does not contain 16 Bytes, this returns `None`:
    ///
    /// ```
    /// # use gbl::*;
    /// # fn run() -> Result<(), Error> {
    /// assert!(AesKey::from_slice(&[
    ///		0xE7, 0xE5, 0x56, 0xB6, 0x35, 0xA3, 0x52, 0x06, // 8
    /// 	0x59, 0xA2, 0xE1, 0x61, 0xCB, 0xDF, 0x4B, 0xC2, // 16
    /// 	0xFF,  // 17
    ///	]).is_none());
    /// # Ok(()) }    fn main() { run().unwrap() }
    /// ```
    ///
    /// [`AesKey::from_raw`]: #method.from_raw
    pub fn from_slice(slice: &[u8]) -> Option<Self> {
        if slice.len() == 16 {
            let mut raw = [0; 16];
            raw.copy_from_slice(slice);
            Some(Self::from_raw(raw))
        } else {
            None
        }
    }

    /// Parses an AES key from a hexadecimal string.
    ///
    /// # Examples
    ///
    /// ```
    /// # use gbl::*;
    /// # fn run() -> Result<(), Error> {
    /// let key = AesKey::from_hex_str("E7E556B635A3520659A2E161CBDF4BC2")?;
    /// # Ok(()) }    fn main() { run().unwrap() }
    /// ```
    pub fn from_hex_str<S: AsRef<str>>(s: S) -> Result<Self, Error> {
        let raw = <[u8; 16]>::from_hex(s.as_ref()).map_err(|e| {
            Error::parse_err(format!("couldn't parse AES key from hex string: {}", e))
        })?;
        Ok(Self::from_raw(raw))
    }

    /// Parses an AES key from a bootloader token file.
    ///
    /// # Parameters
    ///
    /// * `contents`: Contents of the bootloader token file generated by (eg.)
    ///   `commander gbl keygen --type aes-ccm`. Must contain the key
    ///   `TOKEN_MFG_SECURE_BOOTLOADER_KEY`.
    ///
    /// # Examples
    ///
    /// Load a key from an example token file:
    ///
    /// ```
    /// # use gbl::*;
    /// # fn run() -> Result<(), Error> {
    /// let contents = r"
    /// 	## Key randomly generated
    /// 	TOKEN_MFG_SECURE_BOOTLOADER_KEY: E7E556B635A3520659A2E161CBDF4BC2
    /// ";
    ///
    /// let key = AesKey::from_token_file(contents)?;
    /// # Ok(()) }    fn main() { run().unwrap() }
    /// ```
    pub fn from_token_file<S: AsRef<str>>(contents: S) -> Result<Self, Error> {
        const BL_KEY: &str = "TOKEN_MFG_SECURE_BOOTLOADER_KEY";

        let mut parsed_aes_key = None;
        for line in contents.as_ref().lines() {
            let line = line.trim();
            if line.starts_with('#') || line.is_empty() {
                continue;
            }

            let mut split = line.splitn(2, ':');
            let key = split.next().unwrap();
            let value = split
                .next()
                .ok_or_else(|| Error::parse_err(format!("malformed line: {}", line)))?;
            let key = key.trim();
            let value = value.trim();

            if key != BL_KEY {
                return Err(Error::parse_err(format!(
                    "invalid key in token file: got '{}', expected '{}'",
                    key, BL_KEY
                )));
            }

            // parse the associated 128-bit AES key (in hexadecimal notation)
            let aes_key = AesKey::from_hex_str(value)?;

            if parsed_aes_key.is_some() {
                return Err(Error::parse_err("duplicate AES key entry"));
            }

            parsed_aes_key = Some(aes_key);
        }

        parsed_aes_key.ok_or_else(|| Error::parse_err("no AES key found in token file"))
    }

    /// Returns a reference to the raw 16-Byte AES-128 key.
    pub fn as_raw(&self) -> &[u8; 16] {
        &self.0
    }

    /// Consumes `self` and returns the raw bytes making up the key.
    pub fn into_raw(self) -> [u8; 16] {
        self.0
    }
}

impl AsRef<[u8]> for AesKey {
    fn as_ref(&self) -> &[u8] {
        &self.0
    }
}

impl AsRef<[u8; 16]> for AesKey {
    fn as_ref(&self) -> &[u8; 16] {
        &self.0
    }
}

impl Into<[u8; 16]> for AesKey {
    fn into(self) -> [u8; 16] {
        self.0
    }
}

impl From<[u8; 16]> for AesKey {
    fn from(raw: [u8; 16]) -> Self {
        AesKey(raw)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn wrong_number_of_hex_digits() {
        AesKey::from_hex_str("E7E556B635A3520659A2E161CBDF4BC")
            .err()
            .unwrap();
        AesKey::from_hex_str("E7E556B635A3520659A2E161CBDF4BC2").unwrap();
        AesKey::from_hex_str("E7E556B635A3520659A2E161CBDF4BC2F")
            .err()
            .unwrap();
    }

    #[test]
    fn non_hex() {
        AesKey::from_hex_str("E7E556B635A3520659A2E161CBDF4BCX")
            .err()
            .unwrap();
        AesKey::from_hex_str("X7E556B635A3520659A2E161CBDF4BC2")
            .err()
            .unwrap();
        AesKey::from_hex_str("").err().unwrap();
        AesKey::from_hex_str("\0").err().unwrap();
    }

    #[test]
    fn from_slice() {
        let array = [
            0xE7, 0xE5, 0x56, 0xB6, 0x35, 0xA3, 0x52, 0x06, 0x59, 0xA2, 0xE1, 0x61, 0xCB, 0xDF,
            0x4B, 0xC2,
        ];
        let slice: &[u8] = &array;

        let key = AesKey::from_raw(array);
        assert!(AesKey::from_slice(&[]).is_none());
        assert!(AesKey::from_slice(&slice[1..]).is_none());
        assert_eq!(AesKey::from_slice(slice).unwrap().as_raw(), key.as_raw());
    }
}
